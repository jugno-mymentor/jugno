name: on-merge-to-main

# See: https://nvie.com/posts/a-successful-git-branching-model/
# See: https://towardsdatascience.com/setup-version-increment-and-automated-release-process-591d87ea1221

on:
  pull_request:
    branches:
      - main
    types:
      - closed

  workflow_dispatch:
    branches:
      - main

jobs:
  on-merge-to-main:
    name: on-merge-to-main
    # See: https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request
    # See: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request

    if:  ${{(github.event_name == 'pull_request' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'}}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout service
        uses: actions/checkout@v3

      - name: Setup JDK
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'

      - name: Cache Maven packages
        uses: actions/cache@v2
        with:
          path: ~/.m2
          #          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          key: ${{ runner.os }}-m2-${{ hashFiles('pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Run terraform tests
        run: echo "Running terraform tests"

      - name: Run helm tests
        run: echo "Running helm tests"

      - name: Deploy changes
        run: echo "Deploying changes"

      - name: Ensure roll-out
        run: echo "Ensuring rollout"

      # We can either login using a GitHub Action as below OR we can pass GITHUB_TOKEN as env var to the mvn process
      # (See Build step below on how it is passed as env var to mvn process).
#      - name: Login to GitHub Container Registry
#        uses: docker/login-action@v1
#        with:
#          registry: ghcr.io
#          username: ${{github.actor}}
#          password: ${{secrets.GITHUB_TOKEN}}

      - name: Setting environment variables..
        run: |
          echo "AWS_REGION=us-west-2" >> $GITHUB_ENV
          echo "AWS_SG_NAME=jawad-security-group-postgres" >> $GITHUB_ENV

      - name: Add Github Actions IP to Security group
        run: |
          aws rds authorize-db-security-group-ingress --db-security-group-name ${{ env.AWS_SG_NAME }} --protocol tcp --port 5432 --cidr ${{ steps.ip.outputs.ipv4 }}/32
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Build
        run: mvn --activate-profiles cicd --batch-mode clean test
        # The 'deploy' goal will need to authentication to GitHub packages to be able to push the docker image.
        # We will make use of the GitHub provided secret 'secrets.GITHUB_TOKEN' to do that. Note that in this context
        # (i.e. a repository workflow) the token that secrets.GITHUB_TOKEN refers to is a repository level token
        # and NOT an organization level one. So in order for it to work, we first have to publish with a PAT and
        # then later we need to link the uploaded package (aka image) to the repository. And set permission of the
        # package so that the repository can read/write. Only then the GITHUB_TOKEN can be used to publish. Otherwise,
        # the repo level GITHUB_TOKEN will not have the 'write' permission (which is needed to publish/upload the image)
        env:
          GITHUB_PACKAGES_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        # TODO-CICD: some random thoughts (didnt want to delete):
        # Deploy should just publish docker image on remote repo. Release should be a separate proces.
        # I think release should be via tag that is applied manually to main branch head commit. (if we had develop
        # branch then we would do this on dev instead of main).
        #
        # After merge we would clean build, and run all tests again before merg. on failure we can create issue and assign
        # to merge user. mark it as high priority. next level would be to create a bug branch (with bug dev as
        # owner i.e. owner of github.head_ref will be set to bug dev) and then reset the head of dev branch (so
        # it becomes stable again) and create issue and assign
        #        to bug dev. auto branch creation makes sense here if we have to reset dev head to prev commit bc then if we
        #        dont create branch then that commit
        #        will be lost and would have to manually use ref db to create branch with that commit as its head.
        #
        #        since we dont have develop branch yet so Here we should first do things like maven clean build run all tests
        #        on main then deploy to development
        #         run: echo "trigger clean deploy and release? i think release should be via tag that is aplied manually to main branch head commit.
        #        once tag is applied then an on release tag workflow should trigger release goal. which should not only bump versions but also deploy to prod.
        #        before release,

      - name: Remove Github Actions IP from security group
        run: |
          aws rds revoke-db-security-group-ingress --db-security-group-name ${{ env.AWS_SG_NAME }} --protocol tcp --port 5432 --cidr ${{ steps.ip.outputs.ipv4 }}/32
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
        if: always()

      - name: done
        run: echo "Done!"

        #uploading artifacts example (to share output between jobs is one use case)
        # https://docs:github:com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven:

# see example of creating issue via github api at:
#https://docs.github.com/en/actions/security-guides/automatic-token-authentication
